<html lang="ja">
  <head>
    <meta charset="utf-8" />
    <script type="importmap">
      {
        "imports": {
          "three": "/npm/three/build/three.module.js",
          "three/addons/": "/npm/three/examples/jsm/",
          "pixiv/three-vrm": "/npm/@pixiv/three-vrm/lib/three-vrm.module.min.js",
          "cannon-es": "/npm/cannon-es/dist/cannon-es.js",
          "cannon-es-debugger": "/npm/cannon-es-debugger/dist/cannon-es-debugger.js"
        }
      }
    </script>
  </head>

  <body>
    <canvas id="myCanvas" style="position:absolute;left:0px;top:0px;"></canvas>
    <div  id="ui_chat" style="left:0px;top:0px;position:absolute;width:100vw;height:100vh;pointer-events:none;">
      <div id="ui_log" style="position:absolute;width:30vw;height:calc(95vh - 30px);left:auto;top:0px;right:0px;overflow-y: auto;pointer-events:auto;">
        <ul id="log_list" style="padding-left:0px;color:white;width:100%;max-width:100%;word-wrap: break-word;">
        </ul>
      </div>

      <div id="ui_emote"  style="position: absolute; left: 0px; top: auto; bottom: 30px; width: 100vw; height: 30px; pointer-events: auto;">
        <select id="emotes" style="width:120px"></select>
        <button type="button" id="btn_emote" style="width:70px">所作</button>
      </div>

      <div  style="position:absolute;left:0px;top:auto;bottom:0px;width:100vw;height:30px;pointer-events:auto;">
        <button type="button" id="btn_move_room" style="width:70px">部屋移動</button>
        <select id="members" style="width:120px"></select>
        <input type="text" id="message" style="width:calc(97vw - 260px);">
        <button type="button" id="btn_log" style="width:70px">ログ切替</button>
      </div>
    </div>

    <script type="module">
      import * as THREE from "three";
      import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
      import { VRMLoaderPlugin ,VRMUtils} from 'pixiv/three-vrm';
      import { loadMixamoAnimation } from './loadMixamoAnimation.js';
      import { OrbitControls } from "three/addons/controls/OrbitControls.js";
      import { CSS3DRenderer } from "three/addons/renderers/CSS3DRenderer.js";
      import { CSS3DObject } from "three/addons/renderers/CSS3DRenderer.js";
      import { CSS3DSprite } from "three/addons/renderers/CSS3DRenderer.js";
      import * as CANNON from 'cannon-es';
      import CannonDebugger from 'cannon-es-debugger'

      const init = async () =>{

        const default_avatar_url = "asset/vrm/test.vrm";
        //描画dom要素を指定
        const canvasElement = document.querySelector('#myCanvas')
        

        //3D描画関連初期化
        const initRenderSystem = (canvasElement) =>{
          // レンダラーを作成
          const renderer = new THREE.WebGLRenderer({
            canvas: canvasElement,
          });
          renderer.setPixelRatio(window.devicePixelRatio);
          renderer.setSize(window.innerWidth, window.innerHeight);
          //名札等表示用のレンダラー
          const labelRenderer = new CSS3DRenderer();
          labelRenderer.setSize(window.innerWidth, window.innerHeight);
          labelRenderer.domElement.style.position = "absolute";
          labelRenderer.domElement.style.left = "0px";
          labelRenderer.domElement.style.top = "0px";
          labelRenderer.domElement.style.width = "100vw";
          labelRenderer.domElement.style.height = "100vh";
          labelRenderer.domElement.style.pointerEvents = "none";
          document.body.appendChild(labelRenderer.domElement);

          //オブジェクト毎に更新処理はありうるのでそれを積む辞書
          const dic_ticks = {};
          //インスタンス破棄等で不要になったら辞書から削除する
          //更新関数の引数は前のフレームからの経過時間
          const clock = new THREE.Clock()
          // 毎フレーム実行される関数
          const animation_loop = () =>{
            const dt = clock.getDelta();//前のフレームからの経過時間
            //登録済みの更新関数を実行する
            for(const key in dic_ticks){
              dic_ticks[key](dt);
            }
            renderer.render(scene, camera); // 3Dレンダリング
            labelRenderer.render(scene, camera);// 名札等レンダリング
            requestAnimationFrame(animation_loop);
          };
          
          // カメラを作成
          const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight);
          camera.position.set(0, 2, -3);


          //リサイズ対応
          window.addEventListener("resize", (e) => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            labelRenderer.setSize(window.innerWidth, window.innerHeight);
          });
          // シーンを作成
          const scene = new THREE.Scene();
          return [scene,camera,animation_loop,dic_ticks];
        };
        //初期化関数を呼んで他の処理で使う変数を取得
        const [scene,camera,animation_loop,dic_ticks] = initRenderSystem(canvasElement);



        //cannon-es を使った物理演算処理
        //基本的にローカルプレイヤーと地形だけ判定してプレイヤーの位置と速度を計算する。
        //リモートプレイヤーについては位置同期を信用する。
        //ゲーム等で位置が問題にな場合は、サーバかホストで全部処理してクライアントに全員の位置を送信することになる
        const initPhysics = () =>{
          const world = new CANNON.World();
          world.broadphase = new CANNON.SAPBroadphase(world);
          world.allowSleep = true;
          world.gravity.set(0, - 9.82, 0);
          return world;
        }
        const phys_world = initPhysics();
        //物理判定デバッグ用
        var cannonDebugger = null;
        //物理判定を可視化して確認する場合はここをtrueに
        const phys_debug = false;

        var player_body;//ローカルプレイヤーの物理ボディ
        //ローカル以外のプレイヤーは物理演算しない
        
        //物理判定レイヤー定義
        const PHYS_GROUP_PLAYER = 1;
        const PHYS_GROUP_LAND = 1;

        const with_grounds = {};//現在プレイヤーに接地している地形の辞書 キーは地形のid
        //プレイヤーが地形に接触したイベントをとりたいときはここで定義
        //引数は以下の項目を持つ辞書
        //with 接触したボディ
        //point 接触位置
        //impact 接触速度
        //grouded 接地状態
        const onPlayerEnterCollide = (e) =>{
          console.log("onPlayerEnterCollide",e);
        };

        //プレイヤーが地形から離れたイベントをとりたいときはここで定義
        //引数は以下の項目を持つ辞書
        //with 接触したボディ
        //grouded 接地か？
        const onPlayerLeaveCollide = (e) =>{
          console.log("onPlayerLeaveCollide",e);
        };
        
        
        const createPlayerBody = (obj) =>{
          //プレイヤーのコンテナを渡してその位置に物理ボディを作る
          //objの位置の上0.25に半径0.25の球を作ることで足元を設置させる。
          //球にする理由はある程度小さい段差は乗り越えるため
          const radius = 0.25;
          const ox =obj.position.x;
          const oy =obj.position.y + 0.25;
          const oz =obj.position.z;
          const sphereShape = new CANNON.Sphere(radius)

          player_body = new CANNON.Body({ 
            mass: 1, 
            shape: sphereShape ,
            collisionFilterGroup: PHYS_GROUP_PLAYER, 
            collisionFilterMask: PHYS_GROUP_LAND , 
          });
          player_body.position.set(ox,oy+5,oz);
          player_body.angularFactor.set(0,0,0);
          phys_world.addBody(player_body);

          player_body.addEventListener('collide', (event)=> {
            //console.log("collide",event);
            //contact.biが自身
            //contact.bjが対象
            //contact.riはローカル衝突位置
            //半径0.25の球なので
            //contact.ri.yがマイナスなら接地と考えられる
            //contact.getImpactVelocityAlongNormalは衝突速度
            const contact = event.contact;
            if(contact.ri.y <0){
              with_grounds[contact.bj.id]=1;
            }
            const point = {x:0,y:0,z:0};
            point.x = player_body.position.x + contact.ri.x;
            point.y = player_body.position.y + contact.ri.y;
            point.z = player_body.position.z + contact.ri.z;
            const impact = contact.getImpactVelocityAlongNormal();
            const num_contacts = Object.keys(with_grounds).length;
            const grounded = (num_contacts>0);
            onPlayerEnterCollide({with:contact.bj,point:point,impact:impact,grounded:grounded});
            
          });

          //離脱はbodyにはイベントないのでworldでやるしかない
          phys_world.addEventListener('endContact', (event)=> {
            var collide_with = null;
            if(event.bodyA===player_body ){
              collide_with = event.bodyB;
            }else if(event.bodyB===player_body){
              collide_with = event.bodyA;
            };
            if(collide_with){
              if(collide_with.id in with_grounds){
                delete with_grounds[collide_with.id];
              }
              const num_contacts = Object.keys(with_grounds).length;
              const grounded = (num_contacts>0);
              onPlayerEnterCollide({with:collide_with,grounded:grounded});
            }
            
          });
          
        }
        const setPlayerVelocity = (vx,vz) =>{
          //水平移動速度設定
          //移動入力から設定
          //入力速度は上限
          const org_vx = player_body.velocity.x;
          const org_vz = player_body.velocity.z;
          if(org_vx==0 && org_vz==0){
            //静止からの初動だけ速度上書きだと動かない場合がある
            player_body.applyImpulse(new CANNON.Vec3(vx, 0, vz));
          }else{
            player_body.velocity.x=vx;
            player_body.velocity.z=vz;            
          }
        }
        const setPlayerJump = (jump_power) =>{
          player_body.applyImpulse(new CANNON.Vec3(0, jump_power, 0));
        }

        const getPlayerPhysics = () =>{
          //現在のプレイヤーの物理ボディの位置と速度を返す
          //位置は物理のyから-0.25した値を返す
          return {
            px:player_body.position.x,
            py:player_body.position.y- 0.25,
            pz:player_body.position.z,
            vx:player_body.velocity.x,
            vy:player_body.velocity.y,
            vz:player_body.velocity.z,
          };
        }
        const land_bodies = [];//地形ボディの配列
        const createStaticBody = (px,py,pz,sx,sy,sz) =>{
          //中心と大きさを渡して物理判定を作る
          //地面とか床用
          const cubeShape = new CANNON.Box(new CANNON.Vec3(sx/2, sy/2, sz/2));
          const cubeBody = new CANNON.Body({
            mass: 0, // 0 is static
            position: new CANNON.Vec3(px, py, pz),
            collisionFilterGroup: PHYS_GROUP_LAND, 
          });
          cubeBody.addShape(cubeShape); 
          land_bodies.push(cubeBody);
          phys_world.addBody(cubeBody); 
        }
        var phys_q = new THREE.Quaternion();
        var phys_p = new THREE.Vector3();
        var phys_s = new THREE.Vector3();
        const createStaticBodyFromMesh = (mesh) =>{
          //箱メッシュを渡して物理判定を作る
          //BoxGeometryは1,1,1でScaleでサイズ調整する前提
          mesh.getWorldQuaternion(phys_q);
          mesh.getWorldPosition(phys_p);
          mesh.getWorldScale(phys_s);
          const sx = mesh.geometry.parameters.width*phys_s.x;
          const sy = mesh.geometry.parameters.height*phys_s.y;
          const sz = mesh.geometry.parameters.depth*phys_s.z;          
          const cubeShape = new CANNON.Box(new CANNON.Vec3(sx/2, sy/2, sz/2));
          const cubeBody = new CANNON.Body({
            mass: 0, // 0 is static
            collisionFilterGroup: PHYS_GROUP_LAND, 
          });
          cubeBody.addShape(cubeShape); 
          cubeBody.position.copy(phys_p); 
          cubeBody.quaternion.copy(phys_q); 
          land_bodies.push(cubeBody);
          phys_world.addBody(cubeBody); 
        }
        
        //2点間にある物理判定の検出クラス
        //始点から終点にrayを投げて最初にヒットした位置と距離を得る
        class PhysRay{
          constructor(bodies){
            /*
              引数
              bodies  判定対象とするCANNON.Bodyの配列
            */
            this.ray = new CANNON.Ray();
            this.ray.skipBackfaces = true;//裏面無視
            this.res = new CANNON.RaycastResult();
            this.bodies = bodies;
            this.nearest_position = new CANNON.Vec3();
            this.nearest_normal = new CANNON.Vec3();
            this.nearest_distance = -1;
          }
          castRay(from,to,mask){
            /*
              引数 
              from 検出始点
              to   検出終点
              mask 検出対象グループ
              戻り値
              fromとtoの間に検出すればtrue
              検出結果の詳細はプロパティを見る
              this.nearest_distance 距離
              this.nearest_position 位置
              this.nearest_normal   法線
            */
            this.ray.collisionFilterMask = mask;
            this.ray.from.copy(from);
            this.ray.to.copy(to);
            //intersectBodiesは複数ヒットする場合ソートしてくれない
            //それ故intersectBodyをループで呼び出して自前で最短を取得する必要がある
            //intersectBodiesは内部でintersectBodyを呼んでいるので効率はほとんどかわらんはず
            var min_distance = 100000000;//十分に大きい数字
            var found = false;
            for(const body of this.bodies){
              this.res.reset();
              this.ray.intersectBody(body,this.res);
              if(this.res.hasHit){
                const distance = this.res.distance;
                if(distance < min_distance){
                  min_distance = distance;
                  this.nearest_distance = distance;
                  this.nearest_position.copy(this.res.hitPointWorld);
                  this.nearest_normal.copy(this.res.hitNormalWorld);
                }
                found = true;
              }
            }
            return found;
          }
        }
        
        const fc_ray = new PhysRay(land_bodies);
        const fixFollowCamera = (camera,look_at_pos) =>{
          //追尾始点の時に、地形による遮蔽があった場合は
          //一番近い位置にカメラを移す
          if(fc_ray.castRay(look_at_pos,camera.position,PHYS_GROUP_LAND)){
            camera.position.copy(fc_ray.nearest_position);
            camera.lookAt(look_at_pos);
          }
        }
        
        const tickPhysics = (dt) =>{
          //物理演算をステップ実行
          phys_world.step(1/60,dt);
          if(phys_debug){
            if(cannonDebugger===null){
              cannonDebugger = new CannonDebugger(scene, phys_world);
            }
            cannonDebugger.update();
          }
          //
          if(player_body.position.y < -10 || player_body.position.y > 100){
            //落下したり極端な高さの場合は強制的に初期位置に飛ばす
            player_body.velocity.set(0,0,0);
            player_body.position.set(0,5,0);
          }
        }
        dic_ticks["physics"] = tickPhysics;

        
        //オブジェクトのクリック時処理
        const interactives = [];//クリック判定対象
        const registInteractive = (obj,callback) =>{
          //Object3Dを指定してクリックイベントを設定する
          obj.onclick = callback;
          interactives.push(obj);
        }
        window.addEventListener('click', (evt) => {
          const raycaster = new THREE.Raycaster();
          const vector = new THREE.Vector2(
            (evt.clientX / window.innerWidth) * 2 - 1,
            (evt.clientY / window.innerHeight) * -2 + 1
          );
          raycaster.setFromCamera(vector, camera);
          const intersects = raycaster.intersectObjects(interactives);
          if (intersects.length) {
            var el = intersects[0].object;
            while(!("onclick" in el)){
              el = el.parent;
              if(el === scene){
                return;
              }
            };
            el.onclick(el);
          }
        });
        
        //ワールド初期設定
        //ワールド内に静的なものを追加したい場合はここで記述する
        const setupWorld = (scene) =>{
          // 環境光源を作成
          const light = new THREE.AmbientLight(0xFFFFFF, 1.0);
          scene.add(light);

          //zx平面にグリッド表示 サイズ10 分割10
          var gridHelper = new THREE.GridHelper(10, 10);
          scene.add(gridHelper);
          
          //地面判定追加 
          createStaticBody(0,-1,0,10,2,10);
          
          //追加でものを置きたい場合はここに記述
          /*  箱を置く例 */
          const geometry = new THREE.BoxGeometry(1, 1, 1);//形状
          const material = new THREE.MeshNormalMaterial();//表示材質
          const box = new THREE.Mesh(geometry, material);//面の生成
          box.position.set(0,0.5,3);//位置
          box.rotation.set(0,Math.PI/4,0);//向き
          scene.add(box);
          //物理演算への登録
          createStaticBodyFromMesh(box);
          //クリック時のイベント登録
          registInteractive(box,(obj)=>{
            console.log("clicked",obj);
          });
          
          
          /* 斜面を置く例 */
          const geometry2 = new THREE.BoxGeometry(2, 0.1, 10);//形状
          const slope = new THREE.Mesh(geometry2, material);//面の生成
          slope.position.set(-3,3.5,-3);//位置
          slope.rotation.set(Math.PI/4,0,0);//向き
          scene.add(slope);
          //物理演算への登録
          createStaticBodyFromMesh(slope);
        };
        
        setupWorld(scene);


        //VRMロード処理の定義
        const vrm_loader = new GLTFLoader();
        vrm_loader.register((parser) => {
          return new VRMLoaderPlugin(parser);
        });
        const loadVrmFromUrl = async (path)=>{
          return new Promise(
            (resolve => {
              vrm_loader.load(path, 
                (gltf) => {
                  const vrm = gltf.userData.vrm;
                  resolve(vrm);
                },
                (progress) => console.log('Loading model...', 100.0 * (progress.loaded / progress.total), '%'),
                (error) =>{
                   console.error(error);
                   resolve(false);
                },
              );
            })
          );
        }
        const loadVrmFromArrayBuffer = async (buffer)=>{
          const blob = new Blob( [ buffer ], { type: "application/octet-stream" } );
          const url = URL.createObjectURL( blob );
          return await loadVrmFromUrl(url);
        }




        //メタバースではリモートプレイヤーも表示するので
        //アバター処理をクラスにまとめておく
        //アバター表示・位置設定・モーション追加・モーション再生・名札表示・発言表示
        //のみを扱いそれ以上の管理は外で行う。
        class Avatar {
          constructor(param){
            const that = this;
            this.id = param.id;
            this.name = param.name;
            this.motions = {};//引数と違ってこっちはモーション名がキー
            if(param.motions){
              for(const motion of param.motions){
                this.motions[motion.name] = motion.path;
              }
            }
            this.ticks = param.ticks;
            this.scene = param.scene;
            this.vrm = null;
            this.in_set_vrm = false;//アバター設定中かどうか
            this.current_motion = "";
            this.tick_name = "avatar_tick_"+this.id;
            this.avatar_data = null;
            this.reserved_avatar_data = null;//setAvatar中にsetAvatarされた場合はここに保存して後で解決する
            this.actions = {};
            this.mixer = null;
            this.container = new THREE.Object3D(this.name);
            this.scene.add(this.container);
            if(param.spawn){
              this.container.position.set(param.spawn.x,param.spawn.y,param.spawn.z);
            };         

            this.rotate_speed = param.rotate_speed?param.rotate_speed:1;

            this.ticks[this.tick_name] = (dt) =>{
              that.tick(dt);
            }
            
            //procVelocityはローカルアバター以外は使わない
            this.procVelocity = param.procVelocity?param.procVelocity:()=>{};
            if(!param.procMotion){
              console.error("procMotionが指定されてません");
            }
            this.procMotion = param.procMotion?param.procMotion:()=>{};

            
            this.procMove = param.procMove?param.procMove:this.defaultProcMove;


            //操作系入力保存
            this.input = {forward:0,right:0,rotate:0};
            //入力情報最終更新
            this.last_input_time = 0;

            this.velocity = {x:0,y:0,z:0};
            this.position = {x:0,y:0,z:0,ry:0};
            
            //同期入力保存
            this.wish_pos = {x:0,y:0,z:0,ry:0};
            

            //アバターから見た前・右・上の単位ベクトル計算用
            this.vec_forward = new THREE.Vector3();
            this.vec_right = new THREE.Vector3();
            this.vec_up = new THREE.Vector3(0,1,0);//これは固定
            this.tmp_dir = new THREE.Vector3();
            this.eye_height = 2;//足元基準での目の高さ
            
            //移動量計算用
            this.move_vec_forward = new THREE.Vector3();
            this.move_vec_right = new THREE.Vector3();
            this.move_vec_up = new THREE.Vector3();
            
            //名札処理
            this.nameObj = null;
            this.nameLabel = null;
            this.chatLabel = null;
            this.onclick = param.onclick;
            this.addNamePlate();
          }
          
          //ローカルプレイヤーの入力情報更新時
          setInput(forward,right,rotate){
            this.input.forward = forward;
            this.input.right = right;
            this.last_input_time = Date.now();
          }
          //カメラ操作による向き変更時
          setInputRotate(rotate){
            this.input.rotate = rotate;
            this.last_input_time = Date.now();
          }
          
          //速度設定
          setVelocity(vx,vy,vz){
            this.velocity.x = vx;
            this.velocity.y = vy;
            this.velocity.z = vz;
          }
          
          //リモートプレイヤーの位置情報受信時
          setRemoteInput(x,y,z,ry,forward,right,rotate,vx,vy,vz){
            this.teleport(x,y,z,ry);
            //リモートの場合は速度は入力値で計算しない
            this.input.forward = forward;
            this.input.right = right;
            this.input.rotate = rotate;
            this.setVelocity(vx,vy,vz);
            this.last_input_time = Date.now();

          }

          removeNamePlate(){
            if(this.nameObj){
              //labelはこの時内部処理で削除されている
              this.container.remove(this.nameObj);
            }
          };
          
          addNamePlate(){
            //名札を付ける
            //色を変えるとかクリック時の処理とかは上の階層でやる
            const label = document.createElement("div");
            label.style.color="#ffffff";
            label.style.textAlign="center";
            
            label.onclick = this.onclick;
            const nameLabel = document.createElement("div");
            nameLabel.textContent = this.name;
            label.appendChild(nameLabel);
            this.nameLabel = nameLabel;
            const chatLabel = document.createElement("div");
            chatLabel.style.height="20px";
            label.appendChild(chatLabel);
            this.chatLabel = chatLabel;
            const sprite = new CSS3DSprite(label);
            sprite.oncontextmenu= () =>{ return false; };
            sprite.position.y=2;
            sprite.scale.setScalar(0.01);
            sprite.rotation.set(0, Math.PI, 0);
            this.nameObj = sprite;
            this.container.add(sprite);
          }
          updateNamePlate(){
            //現在のアバターの目の高さ基準で名札の位置を設定する
            if(!this.vrm){
              return;
            }
            this.nameLabel.textContent = this.name;
            this.nameObj.position.y=this.eye_height+0.5;
          };
          
          say(msg){
            if(this.chatLabel){
              const piece = document.createElement("span");
              piece.textContent = msg;
              this.chatLabel.appendChild(piece);
              setTimeout(()=>{
                piece.remove();
              },2000);
            }
          }

          
          tick(dt){
            if(this.vrm){
              //速度決定
              this.procVelocity(this);
              //移動解決
              this.procMove(this,dt);
              //モーション制御
              this.procMotion(this,dt);
              //vrm更新
              this.vrm.update(dt);
              if(this.mixer){
                //モーション解決
                this.mixer.update(dt);
              }
            }
          }
          
          dispose(){
            //退室などでいなくなる場合の対応
            //リモートプレイヤー用
            this.disposeAvatar();
            this.removeNamePlate();
            //アニメーション関数を解除
            if( this.tick_name in this.ticks){
              delete this.ticks[this.tick_name]
            }
          }
          
          async setAvatar(src){
            //設定中に呼ばれた場合、データを保存しておいて
            //処理後にsetAvatarを改めて呼ぶ
            if(this.in_set_vrm){
              this.reserved_avatar_data = src;
              //処理中に複数回呼ばれた場合は最後の設定だけ残す
              console.log("in_set_vrm then ignore new setAvatar ");
              return;
            }
            this.in_set_vrm= true;
            if(this.vrm){
              this.disposeAvatar();
            }
            //最終的に受信データで更新するのでバイナリ対応
            if(typeof(src)=="object"){
              this.vrm = await loadVrmFromArrayBuffer(src);
            }else{
              this.vrm = await loadVrmFromUrl(src);
            }
            this.avatar_data = src;//後から送信する可能性があるので保存
            
            this.container.add(this.vrm.scene);

            //頭の高さの代替として目の高さが欲しい
            var eye = this.vrm.humanoid.getBoneNode("leftEye");//左目のボーン
            var world_eye = new THREE.Vector3();
            eye.getWorldPosition(world_eye);//ワールド座標取得
            this.eye_height = world_eye.y - this.container.position.y;//足元からの高さ
            //名札の位置調整
            this.updateNamePlate();


            
            //actionsリセットしてmixer作り直し
            this.vrm.humanoid.resetNormalizedPose();
            this.actions = {};
            this.mixer = new THREE.AnimationMixer( this.vrm.scene );
            for(const motion_name in this.motions){
              await this.registMotion(this.motions[motion_name],motion_name,false);
            }
            //前のモーションを引き継ぎ
            if(this.current_motion){
              const prev_motion = this.current_motion;
              this.current_motion="";//リセットしないと変化なし扱いでTポーズから待機モーションにならない
              this.playMotion(prev_motion);
            }
            this.in_set_vrm= false;
            
            //setAvatar中にsetAvatar呼ばれた場合の解決
            if(this.reserved_avatar_data){
              const avatar_data = this.reserved_avatar_data;
              this.reserved_avatar_data = null;
              //reserved_avatar_dataを消しているので無限ループにはならない
              await this.setAvatar(avatar_data);
            }
          }
          disposeAvatar(){
            //現在のVRMを破棄する。
            if(this.vrm){
              VRMUtils.deepDispose(this.vrm.scene);
              this.container.remove(this.vrm.scene);
            }
          }
          
          async registMotion(src,name,is_new_motion=false){
            try{
              var path;
              if(typeof(src)=="object"){
                const blob = new Blob( [ src ], { type: "application/octet-stream" } );
                path = URL.createObjectURL( blob );
              }else{
                path = src;
              }
              const clip = await loadMixamoAnimation( path, this.vrm);
              const action = this.mixer.clipAction( clip );
              this.actions[name]=action;
              if(is_new_motion){
                this.motions[name] = src;
              }
              return true;
            }catch(e){
              return false;
            }
          }
          
          hasMotion(name){
            return name in this.actions;
          }

          playMotion(name,force_play = false){
            if(name in this.actions){
              const prev_animation = this.current_motion
              if(prev_animation == name && force_play==false){
                //基本的に現在と同じモーション名の場合は無視
                return;
              }
              const action = this.actions[name];
              this.current_motion = name;
              action.play();
              if( (prev_animation in this.actions) && (prev_animation != name) ){
                const prev_action = this.actions[prev_animation];
                prev_action.stop();
              }
            }
          }

          calcDirection(){
             //移動計算用に現在の単位ベクトルを計算する。
             //前と右のベクトルを計算
             //上は固定

            if(this.vrm){
              const dir = this.vrm.scene.getWorldDirection(this.tmp_dir);
              //dirにはvrmの背後へのベクトルが入っている
              dir.negate();//反転
              this.vec_forward.copy(dir);
              //右を計算したい場合はy軸で-90度回せばいい
              dir.applyAxisAngle(this.vec_up,Math.PI*-0.5);
              this.vec_right.copy(dir);
            }
          }
          
          
          defaultProcMove(avatar,dt){
            //速度による移動解決
            //物理演算を導入する場合はコンストラクタにprocMoveを指定して
            //そっちで解決する
            const dx = this.velocity.x * dt;
            const dy = this.velocity.y * dt;
            const dz = this.velocity.z * dt;
            const dry = this.input.rotate * this.rotate_speed * dt
            //console.log("dry",dry);
            const ax = this.position.x + dx;
            const ay = this.position.y + dy;
            const az = this.position.z + dz;
            const ary = this.position.ry + dry;
            
            this.teleport(ax,ay,az,ary);

          }
          
          
          teleport(x,y,z,ry){
            //絶対座標と向き指定での移動
            this.container.position.set(x,y,z);
            this.container.rotation.y=ry;
            this.wish_pos.x = x;
            this.wish_pos.y = y;
            this.wish_pos.z = z;
            this.wish_pos.ry = ry;
            this.position.x = this.container.position.x;
            this.position.y = this.container.position.y;
            this.position.z = this.container.position.z;
            this.position.ry = this.container.rotation.y;

          }
          
          getPosition(){
            return this.container.position;
          }
        }


        //物理演算に基づく移動
        const procMove = (avatar,dt)=>{
          //向きは物理演算関係なし
          const dry = avatar.input.rotate * avatar.rotate_speed * dt
          const ary = avatar.position.ry + dry;
          
          //物理演算から位置と速度回収
          const info = getPlayerPhysics();
          
          avatar.teleport(info.px,info.py,info.pz,ary);
          avatar.velocity.x = info.vx;
          avatar.velocity.y = info.vy;
          avatar.velocity.z = info.vz;

        }
        
        
        //アバターの入力状態による速度計算
        //これはローカルプレイヤー用
        //リモートの場合は受信した速度情報を採用する
        //物理演算等で拡張の余地があるので外部関数に切り出す
        const avatar_velocity = new THREE.Vector3();
        const avatar_velocity_forward = new THREE.Vector3();
        const avatar_velocity_right = new THREE.Vector3();
        const avatar_velocity_up = new THREE.Vector3();
        const procVelocityLocal = (avatar) =>{
          const move_speed = 3;
          avatar.calcDirection();
          //前後入力分
          avatar_velocity_forward.copy(avatar.vec_forward);
          avatar_velocity_forward.multiplyScalar(avatar.input.forward*move_speed);
          //左右入力分
          avatar_velocity_right.copy(avatar.vec_right);
          avatar_velocity_right.multiplyScalar(avatar.input.right*move_speed);

          //上下はここでは更新せず元の値を維持する
          avatar_velocity_up.set(0,avatar.velocity.y,0);
          
          //速度合成
          avatar_velocity.set(0,0,0);
          avatar_velocity.add(avatar_velocity_forward);
          avatar_velocity.add(avatar_velocity_right);
          avatar_velocity.add(avatar_velocity_up);
          
          //物理演算への反映
          setPlayerVelocity(avatar_velocity.x,avatar_velocity.z);
          
        }
        const procVelocityOther = (avatar) =>{
          const move_speed = 3;
          avatar.calcDirection();
          //前後入力分
          avatar_velocity_forward.copy(avatar.vec_forward);
          avatar_velocity_forward.multiplyScalar(avatar.input.forward*move_speed);
          //左右入力分
          avatar_velocity_right.copy(avatar.vec_right);
          avatar_velocity_right.multiplyScalar(avatar.input.right*move_speed);

          //上下はここでは更新せず元の値を維持する
          avatar_velocity_up.set(0,avatar.velocity.y,0);
          
          //速度合成
          avatar_velocity.set(0,0,0);
          avatar_velocity.add(avatar_velocity_forward);
          avatar_velocity.add(avatar_velocity_right);
          avatar_velocity.add(avatar_velocity_up);
          
          //アバターへの書き戻し
          avatar.velocity.x = avatar_velocity.x;
          avatar.velocity.y = avatar_velocity.y;
          avatar.velocity.z = avatar_velocity.z;
        }

        
        //入力状態による歩行/待機の自動切換え用関数
        //横歩きとかジャンプとかの拡張の余地があるので外部関数に切り出す
        const procMotion = (avatar,dt) =>{
          //移動入力を見て現在のモーションと違う場合は更新する。
          const is_move = (avatar.input.forward != 0 ) || (avatar.input.right != 0 ) || (avatar.input.rotate != 0);
          if(is_move && avatar.current_motion!="walk"){
            //移動中かつ現在のモーションが歩行でない
            avatar.playMotion("walk");
          }else if(!is_move  && avatar.current_motion=="walk"){
            //移動中でないかつ現在のモーションが歩行
            avatar.playMotion("idle");
          }else{
            //いずれでもない場合は現在のモーションを維持する。
          }
        }

        //キーボード・マウス操作を移動とカメラに反映するクラス
        //awsdで移動qeで向き変えマウスドラッグでカメラ制御
        //cで追尾/自撮り切り替え
        //ゲームパッド等別の入力手段を使いたい場合は新規にクラスを定義してそっちを使う
        //ランタイムで複数の入力を切り替えたい場合はenabledを設定して切り替える。
        //システム操作的なものはこっちじゃなくてui側で扱う方針
        class InputSystem{
          constructor(param){
            const that = this;
            this.avatar = param.avatar;
            this.camera = param.camera;
            this.enabled = true;
            if("enabled" in param){
              this.enabled = param.enabled;
            }
            
            this.sendTransform = param.sendTransform;
            
            this.canvasElement = param.canvasElement;
            //アバターの移動速度
            this.ticks = param.ticks;

            if(param.fixFollowCamera){
              this.fixFollowCamera=param.fixFollowCamera;
            }else{
              this.fixFollowCamera = () =>{};
            }
            
            //追加のキー操作の登録
            this.key_events = {};
            if(param.key_events){
              for(const code in param.key_events){
                this.key_events[code]=param.key_events[code];
              }
            }

            //移動入力
            this.input_forward = 0;
            this.input_right = 0;
            //回転入力
            this.input_rotate= 0;
            //カメラ上下移動入力
            this.camera_updown = 0;
            //カメラ上下移動累積
            this.camera_updown_amount=0;
            //カメラの目標設定用
            this.look_at_pos = new THREE.Vector3();

            //追尾カメラ処理
            this.camera_vec = new THREE.Vector3();





            //自撮りモード処理
            this.controls = new OrbitControls(camera, canvasElement);
            this.controls.enableDamping = true;
            this.controls.dampingFactor = 0.2;
            this.use_freecamera = false;
            this.controls.enabled = false;//初期状態では無効


            //ドラッグによるカメラ操作対応
            this.pointer_button_state = false;
            this.pointer_move_horizontal = 0;//ドラッグ移動量水平
            this.pointer_move_vertical = 0;//ドラッグ移動量垂直
            this.mouseEventContent = this.canvasElement;
            this.mouseEventContent.addEventListener('pointerdown', (event) => {
              if(!that.enabled){
                return;
              }
              that.mouseEventContent.setPointerCapture(event.pointerId);
              that.pointer_button_state=true;
            });
            this.mouseEventContent.addEventListener('pointermove', (event) => {
              if(!that.enabled){
                return;
              }

              if(that.pointer_button_state){
                //tick毎に積算はリセットする
                that.pointer_move_horizontal += event.movementX;
                that.pointer_move_vertical += event.movementY;
                //console.log(pointer_move_horizontal,pointer_move_vertical);
              }else{
                //ボタン押してない場合はリセット
                that.pointer_move_horizontal = 0;
                that.pointer_move_vertical = 0;
              }
            });
            this.mouseEventContent.addEventListener('pointerup', (event) => {
              if(!that.enabled){
                return;
              }

              that.mouseEventContent.releasePointerCapture(event.pointerId);
              that.input_rotate = 0;
              that.avatar.setInputRotate(0);
              that.camera_updown = 0;
              that.pointer_button_state=false;
            });


            window.addEventListener("keydown",(e)=>{

              if(!that.enabled){
                return;
              }

              //ui操作で移動してほしくないので
              //フォーカスを持っている要素のtagNameがinput selectのいずれかの場合は無視
              if(document.activeElement){
                const tag = document.activeElement.tagName;
                if(tag=="SELECT" || tag=="INPUT"){
                  return;
                }
              }


              //移動入力値更新
              const code = e.code;
              let is_change_move = false;
              let is_change_rotate = false;

              if(code=="KeyW"){
                that.input_forward=1;
                is_change_move = true;
              }else if(code=="KeyS"){
                that.input_forward=-1;
                is_change_move = true;
              }else if(code=="KeyA"){
                that.input_right = -1;
                is_change_move = true;
              }else if(code=="KeyD"){
                that.input_right = 1;
                is_change_move = true;
              }else if(code=="KeyQ"){
                that.input_rotate=1;
                is_change_rotate = true;
              }else if(code=="KeyE"){
                that.input_rotate=-1;
                is_change_rotate = true;
              }else if(code=="KeyC"){
                that.use_freecamera = ! that.use_freecamera;
                that.controls.enabled = that.use_freecamera;
              }else if(code in that.key_events){
                that.key_events[code](e);
              }
              if(is_change_move){
                that.avatar.setInput(that.input_forward,that.input_right);
                that.input_count ++;

              }
              if(is_change_rotate){
                that.avatar.setInputRotate(that.input_rotate);
                that.input_count ++;
              }
              
            });
            window.addEventListener("keyup",(e)=>{

              if(!that.enabled){
                return;
              }


              //ui操作で移動してほしくないので
              //フォーカスを持っている要素のtagNameがinput selectのいずれかの場合は無視
              if(document.activeElement){
                const tag = document.activeElement.tagName;
                if(tag=="SELECT" || tag=="INPUT"){
                  return;
                }
              }


              let is_change_move = false;
              let is_change_rotate = false;

              //移動入力値更新
              const code = e.code;
              if(code=="KeyW"){
                that.input_forward=0;
                is_change_move = true;
              }else if(code=="KeyS"){
                that.input_forward=0;
                is_change_move = true;
              }else if(code=="KeyA"){
                that.input_right = 0;
                is_change_move = true;
              }else if(code=="KeyD"){
                that.input_right = 0;
                is_change_move = true;
              }else if(code=="KeyQ"){
                that.input_rotate=0;
                is_change_rotate = true;
              }else if(code=="KeyE"){
                that.input_rotate=0;
                is_change_rotate = true;
              }

              if(is_change_move){
                that.avatar.setInput(that.input_forward,that.input_right);
                that.input_count ++;
              }
              if(is_change_rotate){
                that.avatar.setInputRotate(that.input_rotate);
                that.input_count ++;

              }

            });
            
            //tick処理の登録
            this.ticks["proc_local_player"]= (dt)=>{ 

              if(!that.enabled){
                return;
              }
              that.tickSync(dt);//同期送信
              that.tickDrag(dt);//ドラッグ操作によるカメラ状態変数更新
              that.tickCamera(dt);//カメラ制御
            };

            //同期送信判定用
            this.last_transform_send = 0;
            this.input_count = 0;
            this.last_send_input_count = 0;
            
            this.last_send_position = new THREE.Vector3();
            this.last_send_velocity = new THREE.Vector3();

            
          }
          tickSync(dt){
            //送信の必要性の判定
            //物理演算ありなので
            //位置か速度に変化があって最小間隔以上経過した
            //最大間隔を経過した
            //のいずれかを条件として送信する
            
            const x=this.avatar.position.x;
            const y=this.avatar.position.y;
            const z=this.avatar.position.z;
            const ry = this.avatar.position.ry;
            const vx=this.avatar.velocity.x;
            const vy=this.avatar.velocity.y;
            const vz=this.avatar.velocity.z;
            
            const min_interval = 50;//最小送信間隔
            const max_interval = 1000;//最大送信間隔
            
            var is_change = !(
              this.last_send_position.x==x 
              && this.last_send_position.y==y 
              && this.last_send_position.z==z 
              && this.last_send_velocity.x==vx 
              && this.last_send_velocity.y==vy 
              && this.last_send_velocity.z==vz
            );
            
            
            if( (is_change  && (Date.now() - min_interval > this.last_transform_send)) || (Date.now() - max_interval > this.last_transform_send) ){
              //送信が必要
              const forward = this.avatar.input.forward;
              const right = this.avatar.input.right;
              const rotate = this.avatar.input.rotate;
              
              
              
              
              this.sendTransform(x,y,z,ry,forward,right,rotate,vx,vy,vz);
              this.last_transform_send = Date.now();
              this.last_send_input_count = this.input_count;
              this.last_send_position.set(x,y,z);
              this.last_send_position.set(vx,vy,vz);
              
            }
          }
          
          tickCamera(dt){
            if(this.use_freecamera){
              //自撮りモードの場合は追尾カメラ処理しない
              return;
            }
            this.avatar.calcDirection();
            //カメラの位置はプレイヤーの足元基準で後方5m上3mとする
            this.camera_vec.copy(this.avatar.vec_forward);
            this.camera_vec.multiplyScalar(-5);//後方5m
            this.camera_vec.add(this.avatar.getPosition());
            this.camera_vec.y += this.camera_updown_amount+3;//ドラッグによる操作を反映
            this.camera.position.copy(this.camera_vec);
            //プレイヤーの足元から1mだけ上に移動した位置を見る
            this.look_at_pos.copy(this.avatar.getPosition());
            this.look_at_pos.y += 1;
            this.camera.lookAt(this.look_at_pos);
            //地形遮蔽への対応
            this.fixFollowCamera(this.camera,this.look_at_pos);

          }
          tickDrag(dt){
            if(this.use_freecamera){
              //自撮りモードの場合はドラッグによるカメラ処理しない
              this.pointer_move_horizontal = 0;
              this.pointer_move_vertical = 0;            
              return;
            }

            //ドラッグ操作によるカメラ処理
            if(this.pointer_button_state){
              const p_move_x = this.pointer_move_horizontal / window.devicePixelRatio;
              const p_move_y = this.pointer_move_vertical / window.devicePixelRatio;
              //画面解像度で割った比率で判断しないと体感に合わない

              const threshold_x = 10;//水平閾値 低いと感度大
              const threshold_y = 10;//垂直閾値 低いと感度大
              const rate_x = -0.15;//水平係数 大きいと感度大
              const rate_y = 1.0;//垂直係数 大きいと感度大
              //上下 左右 の移動量大きいほうだけ処理
              if(p_move_y*p_move_y < p_move_x*p_move_x){
                //水平
                if(p_move_x*p_move_x > threshold_x){
                  this.avatar.setInputRotate(p_move_x * rate_x);
                }
                this.camera_updown=0;
              }else{
                //垂直
                if(p_move_y*p_move_y > threshold_y){
                  this.camera_updown = p_move_y * rate_y ;
                }
              }
              this.camera_updown_amount+=this.camera_updown/50;//そのままだと早すぎる
              //ドラッグ量リセット
              this.pointer_move_horizontal=0;
              this.pointer_move_vertical=0;
            }
          }
        }




        const server_port = 10514;
        const server_url = "wss://"+location.hostname+":"+server_port+"/";
        const token_name = "wss_auth_token";

        const pc_config = {"iceServers":[]};//webrtc接続の設定
        /*
          stun/turnサーバなしの例 同じネットワーク内ならこれでよし
          {"iceServers":[]} 
          stunサーバを使う例 途中のルータの設定によってはつながらない
          {'iceServers': [
            { urls: "stun:stun.l.google.com:19302" },
            { urls: "stun:stun1.l.google.com:19302" },
          ]}
          turnサーバを使う例  ほとんどの場合つながる
            ※これは架空の設定なので実際には使えない
            ※turnサーバは基本的に自分で立てる必要がある。
          {'iceServers': [
            {
              urls: "turns:turn3.example.net",
              username: "12334939:fred",
              credential: "adfsaflsjflds"
            }
          ]}
        */
        
        //送信ファイル管理配列
        //転送idをキーとしてファイルデータ・ファイルサイズ・ファイル名を値に持つ
        var send_files = {};
        //受信ファイル管理配列
        //転送idをキーとして受信データ配列・ファイルサイズ・ファイル名を値に持つ
        var recv_files = {};
        
        
        const channels_def= {
          "chat":{
            onopen:(id)=>{
              if(id in id2name){
                appendLog("["+id2name[id]+"]に送信可能になりました");
              }
            },
            "onmessage":(id,data)=>{
              const sender_name = id2name[id];
              try{
                const info = JSON.parse(data);
                var message= sender_name + ": "+info.message;
                if(info.mode=="tell"){
                  message= sender_name + ">>あなた: "+info.message;
                }
                appendLog(message);
                sayOther(id,info.message);
              }catch(e){
              }
            },
          },
          "transform":{
            onopen:(id)=>{
              if(id in id2name){
                createOther(id,id2name[id]);
              }
            },
            "onmessage":(id,data)=>{
              moveOther(id,data);

            },
          },
          "transport":{
            onopen:(id)=>{
              //送信可能になったのでアバター送信
              sendAvatar(id);
            },
            "onmessage":(id,data)=>{
              try{
                const info = JSON.parse(data);
                if(info.mode=="file" || info.mode=="avatar" || info.mode=="motion"){
                  //送信側から送信予告が来た
                  prepareReceiveFile(id,info);
                }
              }catch(e){
              }
              

            },
          },
          "rpc":{
            onopen:(id)=>{
            },
            "onmessage":(id,data)=>{
              try{
                const info = JSON.parse(data);
                if(info.mode=="req_motion"){
                  //エモート用のデータ要求が来た
                  if(local_avatar.hasMotion(info.motion)){
                    //持ってないものは知らん
                    const data = local_avatar.motions[info.motion];
                    prepareSendFile(self_id,id,info.motion,data,"motion")
                  }
                  
                }else if(info.mode=="emote"){
                  if(id in avatars){
                    const avatar = avatars[id];
                    if(avatar.hasMotion(info.motion)){
                      avatar.playMotion();
                    }else{
                      const conn = connections[id];
                      const msg = {"mode":"req_motion","motion":info.motion};
                      conn.send("rpc",JSON.stringify(msg));
                    }
                  }
                }
              }catch(e){
                console.error("rpc",e);
              }
            },
          },




        };
        
        
        


        
        /* P2P接続の通信内容を定義する辞書 
           上の例はチャット用の設定
           チャネル名をキーとして次の値を持つ
            onopen: 接続時のイベントハンドラ 送信元idを受け取る
            onmessage: 受信時のイベントハンドラ 送信元idとデータを受け取る
        */


        
        var id2name = {};//接続idと名前の辞書
        var self_id;//自分の接続id
        var connections={};//接続管理変数 相手の接続idをキーとしてP2P接続を値とする辞書
        
        



        const url = new URL(window.location.href);
        //getパラメータによる初期ルーム = 部屋指定
        const room = url.searchParams.get('room');
        //getパラメータを抜いたurl = ワールド
        const world = url.origin+url.pathname;
        
        //ui要素
        const inp_message = document.getElementById("message");
        const log_list = document.getElementById("log_list");
        const sel_members = document.getElementById("members");
        const btn_move_room = document.getElementById("btn_move_room");
        
        //ログ表示切替
        const ui_log = document.getElementById("ui_log");
        var log_state = 1;
        const btn_log = document.getElementById("btn_log");
        btn_log.onclick = (e) =>{
          log_state = (log_state +1) % 3;
          if(log_state==0){
            ui_log.style.display="none";
          }else if(log_state==1){
            ui_log.style.display="";
            ui_log.style.width = "30vw";

          }else if(log_state==2){
            ui_log.style.display="";
            ui_log.style.width = "95vw";
          }
        }
        

        
        const ui_emote = document.getElementById("ui_emote");
        const btn_emote = document.getElementById("btn_emote");
        const sel_emotes = document.getElementById("emotes");

        const restoreEmote = async () =>{
          //indexedDBに登録されているfbxを全部取得してregistする
          if(self_id in avatars){
            const emotes = await db.getAllData("fbx");
            for(const emote of emotes){
              //emoteには {id:db上のキー ,data:実際に格納している値}
              //が入っているので実際のデータはemote.data
              const data = emote.data.data;
              const filename = emote.data.filename;
              await avatars[self_id].registMotion(data,filename,true);
            }
            setupEmote();
          }
          
        }
        
        const setupEmote=  () =>{
          if(local_avatar){
            const org_num = sel_emotes.length;
            const org_index = sel_emotes.selectedIndex;
            while(sel_emotes.length>0){
              sel_emotes.remove(0);
            };
            for(const key in local_avatar.motions){
              if(key=="idle" || key=="walk"){
                //歩行と待機は無視
                continue;
              }
              const opt = document.createElement("option");
              opt.value = key;
              opt.text = key;
              sel_emotes.add(opt);              
            }
            if(org_index>=0){
              sel_emotes.options[org_index].selected;
            }
            return sel_emotes.length>0;
          }else{
            return false;
          }
        }
        const doEmote = async (name) =>{
          local_avatar.playMotion(name);
          for(const id in connections){
            const conn = connections[id];
            const msg = {"mode":"emote","motion":name};
            conn.send("rpc",JSON.stringify(msg));
          }
        };

        //所作uiの表示切替
        const toggleEmote = () =>{
          if(ui_emote.style.display=="none"){
            if(setupEmote()){
              ui_emote.style.display="";
            }
          }else{
            ui_emote.style.display="none";
          }
        };
        ui_emote.style.display="none";


        btn_emote.onclick = () =>{
          if(sel_emotes.selectedIndex>=0){
            doEmote(sel_emotes.options[sel_emotes.selectedIndex].value);
          }
        }


        
        //アバター(箱)のコンテナ要素
        const box_space = document.getElementById("box_space");


        //非同期入力関数
        //非同期prompt関数
        const promptAsync = async (message_text,default_value="") => {
          let dialog = document.createElement('dialog');
          let message = document.createElement('p');
          message.textContent = message_text;
          dialog.appendChild(message);
          let input = document.createElement('input');
          input.value = default_value;
          dialog.appendChild(input);
          let ok_button = document.createElement('button');
          ok_button.textContent = "決定";
          if(!default_value){
            ok_button.disabled = true;
          }
          dialog.appendChild(ok_button);
          input.oninput = () =>{
            ok_button.disabled = (input.value=="");
          }
          let cancel_button = document.createElement('button');
          cancel_button.textContent = "中止";
          dialog.appendChild(cancel_button);
          
          document.body.appendChild(dialog);;
          dialog.showModal();
          return new Promise(resolve => {
            const eventBase = flag => () => {
              //空入力でokした場合はキャンセル可能ならキャンセル扱い
              //そうでない場合は無視
              if(flag==true && input.value==""){
                flag = false;
              }
              dialog.close();
              ok_button.removeEventListener("click", okEvent);
              cancel_button.removeEventListener("click", cancelEvent);
              document.body.removeChild(dialog);
              if(flag==true){
                resolve(input.value);
              }else if(flag==false){
                resolve(false);
              }else{
                resolve(flag);
              }
            };
            const okEvent = eventBase(true);
            const cancelEvent = eventBase(false);
            ok_button.addEventListener("click", okEvent);
            cancel_button.addEventListener("click", cancelEvent);
          });
        };


        //非同期ログイン入力関数
        //user_id passwordを持つ連想配列を返す
        const loginAsync = async () => {
          let dialog = document.createElement('dialog');
          let html = "";
          html += "<table>";
          html += "<tr>";
          html += '<td align="right">';
          html += "ID:";
          html += "</td>";
          html += "<td>";
          html += '<input id="user_id">';
          html += "</td>";
          html += "</tr>";
          html += "<tr>";
          html += '<td align="right">';
          html += "PASSWORD:";
          html += "</td>";
          html += "<td>";
          html += '<input id="password" type="password">';
          html += "</td>";
          html += "</tr>";
          html += "<tr>";
          html += "<td colspan=2>";
          html += '<input id="btn_login" type="button" value="LOGIN">';
          html += "</td>";
          html += "</tr>";
          html += "</table>";
          dialog.innerHTML = html;
          document.body.appendChild(dialog);
          const btn_login = document.getElementById('btn_login');
          const inp_user_id = document.getElementById('user_id');
          const inp_password = document.getElementById('password');
          
          dialog.showModal();
          return new Promise(resolve => {
            const eventBase = flag => () => {
              //空入力でokした場合はキャンセル可能ならキャンセル扱い
              //そうでない場合は無視
              const user_id = inp_user_id.value;
              const password = inp_password.value;
              if(flag==true && (user_id=="" || password.value=="")){
                flag = false;
              }
              dialog.close();
              btn_login.removeEventListener("click", okEvent);
              document.body.removeChild(dialog);
              if(flag==true){
                resolve({"user_id":user_id,"password":password});
              }else if(flag==false){
                resolve(false);
              }else{
                resolve(flag);
              }
            };
            const okEvent = eventBase(true);
            btn_login.addEventListener("click", okEvent);
          });
        };



        
        const moveRoom = async () =>{
          const new_room = await promptAsync("部屋名を入力してください");
          if(new_room){
            location.href = world + "?room=" + new_room;
            return true;
          }else{
            return false;
          }
        }
        
        //部屋名必須
        if(!room){
          while(true){
            const ret = await moveRoom();
            if(ret){
              break;
            }
          }
          return;
        }
        
        
        //ここにいる時点でroomは指定されている。
        
        //indexedDBを扱いやすくするラッパークラス
        class DB{
          constructor(db_name,storenames){
            this.db_name = db_name;
            this.storenames = storenames;
            this.db = null;
            this.stores = {};
          }
          
          
          _opendb(){
            const that =this;
            return new Promise((resolve,reject) => {
              try {
                const request = window.indexedDB.open(that.db_name, 3);
                request.onupgradeneeded = (event) => {
                  const db = event.target.result;
                  for(const storename of that.storenames){
                    if (!db.objectStoreNames.contains(storename)) {
                      db.createObjectStore(storename, { keyPath: 'id' });
                    }
                  }
                };
                request.onsuccess = (event) => {
                  const db = event.target.result;
                  resolve(db);
                };
                request.onerror = (event) => {
                  console.log(event.target.error);
                  reject(null);
                };
              } catch (error) {
                console.log(error);
                reject(error);
              }
            });
          }
          
          async openDatabase(){
            //setData/getDataを使う前にこれをawaitで実行する
            this.db = await this._opendb();
          }
          closeDatabase(){
            if(this.db){
              this.db.close();
              this.db = null;
            }
          }
          removeDatabase(){
            //何故か開発ツールでdbごと消す機能がないので実装
            //アンインストール的なことをする場合に呼ぶ想定
            const that = this;
            return new Promise((resolve,reject) => {
              that.closeDatabase();//openしている場合閉じないと削除できない。
              const req= window.indexedDB.deleteDatabase(that.db_name);
              req.onsuccess = (event) => {
                resolve(true);
                console.log("データベース["+that.db_name+"]が正常に削除されました。");
              };
              req.onerror  = (e) =>{
                reject(false);
                console.log("データベース["+that.db_name+"]の削除に失敗しました。");
              };
            });
          }
          
          getStore(storename){
            if(storename in this.stores){
              return this.stores[storename];
            }else{
              const transaction =  this.db.transaction([storename], 'readwrite');
              return transaction.objectStore(storename);
            }
          }

          getAllData(storename){
            const that = this;
            const store = this.getStore(storename);
            return new Promise((resolve,reject) => {
              try{
                const request = store.getAll();
                request.onsuccess = (event) => {
                  if (event.target) {
                    const result = event.target.result;
                    if(result){
                      resolve(result);
                    }else{
                      resolve(null);
                    }
                  }
                };
              }catch(e){
                console.log(e);
                reject(null);
              }
            });
          }
          
          getData(storename,key){
            const that = this;
            const store = this.getStore(storename);
            return new Promise((resolve,reject) => {
              try{
                const request = store.get(key);
                request.onsuccess = (event) => {
                  if (event.target) {
                    const result = event.target.result;
                    if(result){
                      resolve(result.data);
                    }else{
                      resolve(null);
                    }
                  }
                };
              }catch(e){
                console.log(e);
                reject(null);
              }
            });
          }
          
          setData(storename,key,value){
            const that = this;
            const store = this.getStore(storename);
            return new Promise((resolve,reject) => {
              try{
                const request = store.put({id:key,data:value});
                request.onsuccess = (event) => {
                  resolve(true);
                };
              }catch(e){
                console.log(e);
                reject(false);
              }
            });
          }
        }
        
        const db = new DB("p2p_syncvrm",["vrm","fbx"]);


        
        //arrayBufferの配列を結合する
        const joinArrayBuffer = (segments)=>{
          var sumLength = 0;
          for(var i = 0; i < segments.length; ++i){
            sumLength += segments[i].byteLength;
          }
          var whole = new Uint8Array(sumLength);
          var pos = 0;
          for(var i = 0; i < segments.length; ++i){
            whole.set(new Uint8Array(segments[i]),pos);
            pos += segments[i].byteLength;
          }
          return whole.buffer;
        }

        const onCompleteFileReceive = async (id,transport_id) =>{
          //ファイル受信完了時処理
          const info = recv_files[transport_id];
          const filename = info.filename;
          const mode = info.mode;
          const data = joinArrayBuffer(info.chunks);
          if(mode=="file"){
            //チャットログにリンクを張る
            var blob = new Blob([data], {type: "octet/stream"});
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.download = filename;
            a.href = url;
            a.target = "_blank";

            const name = id2name[id];
            a.innerHTML = "ダウンロード";

            const li = document.createElement("li");
            li.textContent = name+"が"+filename+"を送信しました ";
            li.appendChild(a);
            appendLogElement(li);

          }else if(mode=="avatar"){
            await setRemoteAvatar(id,data,filename);
          }else if(mode=="motion"){
            //要求したモーションデータが来た
            await setRemoteMotion(id,data,filename);
          }
        }
        //ファイル転送予告を受信したときの処理
        const prepareReceiveFile= (id,info)=>{
          const mode = info.mode;
          const transport_id = info.transport_id;//転送id
          const filename = info.filename;
          const filesize = info.filesize;
          //管理変数に情報を積む
          recv_files[transport_id]={
            "mode":mode,
            "sender":id,
            "filename":filename,
            "filesize":filesize,
            "chunks":[],
          };
          const conn = connections[id];
          //ファイル転送用データチャネル作成
          const peer = conn.peer;
          const channel = peer.createDataChannel(transport_id);
          var amount = 0;//受信済みサイズ
          channel.onmessage = async (event) =>{
            const piece = event.data;
            recv_files[transport_id].chunks.push(piece);
            amount += event.data.byteLength;
            if(amount>=filesize){
              //受信完了
              await onCompleteFileReceive(id,transport_id);
              //管理配列から削除
              delete recv_files[transport_id];
              //受信側で閉じる
              channel.close();
            }
          };
        };
        

        var transport_count = 0;//ファイル転送回数
        //ファイル転送通知処理
        const prepareSendFile = (sender,target,filename,data,mode="file") =>{
          if(!(target in connections)){
            //接続確立前
            return;
          }
          const conn = connections[target];
          if(!conn.canSend("transport")){
            //送信可能になる前
            if(target in id2name){
              appendLog(id2name[target]+"はファイル受信できない状態です");
            }
          }
          
          
          //全員に送りたい場合は人数分呼ぶ
          const filesize = data.byteLength;
          transport_count += 1;
          //転送id決定
          const transport_id = "file_" + sender + "_"+transport_count;
          //管理変数に情報を積む
          send_files[transport_id]={
            "mode":mode,
            "target":target,
            "filename":filename,
            "filesize":filesize,
            "data":data,
          };
          
          //転送予告を通知する
          const transport_msg = {"mode":mode,"transport_id":transport_id,"filename":filename,"filesize":filesize};
          conn.send("transport",JSON.stringify(transport_msg));
          //通知を受けて受信側がデータチャネルを作ると送信側でondatachannelが発火する
        }
        
        //ファイル転送送信側処理
        const startSendFile = async (channel,transport_id) =>{
          const info = send_files[transport_id];
          const data = info.data;
          const total = data.byteLength;
          let remain = total;
          const chunk = 50*1024;//上限は64kbだが余裕を見て50kb
          let begin = 0;
          let end = chunk;
          if( end > total ){
            end = total;
          };
          const limit = 65535 - chunk;//上限 - chunkサイズ の空きがあれば大丈夫と考える
          channel.bufferedAmountLowThreshold = limit;
          //１回分の送信処理
          const proc_send = () =>{
            //切り出し
            let buff = data.slice(begin,end);
            channel.send(buff);
            let sz = buff.byteLength;
            remain -= sz;
            console.log(transport_id,"remain",remain);
            begin += sz;
            end = begin+chunk;
            if( remain < 1 ){
              //完了したのでイベント削除
              channel.removeEventListener("bufferedamountlow",proc_send,false);
              console.log("upload done",transport_id);
              if(info.target in id2name){
                const name = id2name[info.target];
                if(info.mode=="file"){
                  appendLog(info.filename+"の" + name + "への送信が完了しました。");
                }
                //管理配列から削除する
                delete send_files[transport_id];
              }
              //この時点で閉じるとまだ転送中で受信失敗するので閉じるのは受信側
            };
          };
          //キューに空きが出来たら送信するイベント設定
          channel.addEventListener("bufferedamountlow",proc_send,false);
          //初回送信
          proc_send();
          
        }


        
        const onUnknownChannel = (channel) =>{
          if(channel.label in send_files){
            //ファイル転送用データチャネルが湧いた
            const transport_id = channel.label;
            channel.onopen = () =>{
              //開通したので分割送信する
              startSendFile(channel,transport_id);
            };
          };
        }

        window.addEventListener( 'dragover',( event )=>{
          event.preventDefault();
        } );
        //ファイルドロップ処理
        const onDropFile = async ( event )=>{

          event.preventDefault();

          // read given file then convert it to blob url
          const files = event.dataTransfer.files;
          if ( ! files ) return;

          const file = files[ 0 ];
          if ( ! file ) return;

          const fileType = file.name.split( '.' ).pop().toLowerCase();
          const buffer = await file.arrayBuffer()
          const filename = file.name;

          const is_vrm = filename.match('.(vrm)$');
          const is_fbx = filename.match('.(fbx)$');

          if(is_vrm){
            //vrmの場合はアバター設定扱いにする
            await setLocalAvatar(buffer,filename)
          }
          if(is_fbx){
            //fbxの場合はモーション追加
            await setLocalMotion(buffer,filename)
          }
          //受信後の処理を分けたいのでモード指定
          const mode = is_vrm?"avatar":(is_fbx?"motion":"file");
          
          const sender = self_id;
          //発信対象に対してファイルを転送する
          if(mode=="file"){
            //アバターとモーションについては表示しないことにする
            appendLog(filename+ "の送信を開始しました。");
          }
          if(sel_members.selectedIndex > 0 && mode=="file"){
            //個別指定あり
            //アバターやモーション場合は強制的に全体送信
            const target = sel_members.options[sel_members.selectedIndex].value;
            prepareSendFile(sender,target,filename,buffer,mode);
          }else{
            //全体送信
            for(const target in connections){
              prepareSendFile(sender,target,filename,buffer,mode);
            }
          }
        };
        window.addEventListener( 'drop', onDropFile);

        /* 
        シグナリング処理は接続毎に必要なのでクラスにまとめている。
        */
        class P2PConnection {
          constructor(param){
            this.local_id = param.local_id;//自分の接続id
            this.remote_id = param.remote_id;//接続先id
            this.pc_config = param.pc_config;//webrtc接続設定
            this.channels_def = param.channels_def;//データチャネル設定
            this.onUnknownChannel = param.onUnknownChannel;//chanels_defにないデータチャネルの処理
            this.channels = {};//データチャネル管理変数 チャネル名をキーとする
            this.onConnect = param.onConnect;//p2p接続確立時のイベントハンドラ
            this.onDisconnect = param.onDisconnect;//p2p接続切断時のイベントハンドラ
            this.peer = null;//RTCPeerConnectionのインスタンス保持
          };
          setup_channel(name,channel){
            const that = this;
            //channels_defに基づいて設定
            if(name in this.channels_def){
              channel.onopen = () =>{
                this.channels_def[name].onopen(this.remote_id);
              }
              channel.onmessage = (event) =>{
                this.channels_def[name].onmessage(this.remote_id,event.data);
              }
              this.channels[name]=channel;
            }else{
              //未定義チャネル
              this.onUnknownChannel(channel);
            }
            
          }

          async offer(){
            const that=this;
            return new Promise( async (resolve) => {
              that.peer = new RTCPeerConnection(that.pc_config);
              //offerの場合は能動的にchannel追加
              for(const name in that.channels_def){
                const channel = that.peer.createDataChannel(name);
                that.setup_channel(name,channel)
              }

              //転送用データチャネルはどっちがcreateDataChannelを実行するか不定なので両方にいる
              that.peer.ondatachannel = (event) => {
                const channel = event.channel;
                //createDataChannelで指定した名前はリモートでもlabelの値に反映される
                that.setup_channel(channel.label,channel);
              }



              that.peer.onicecandidate = (evt)=> {
                if (evt.candidate) {
                  console.log(evt.candidate);
                } else {
                  //この時点でsdpが確定する
                  console.log('empty ice event');
                  //コールバックだと見通しが悪いのでPromiseで値を返す
                  resolve(that.peer.localDescription);
                }
              };
              that.peer.onconnectionstatechange = (ev) => {
                console.log("onconnectionstatechange",that.peer.connectionState);
                if(that.peer.connectionState=="disconnected"){
                  if(that.onDisconect){
                    that.onDisconect(that.remote_id);
                  }
                }else if(that.peer.connectionState=="connected"){
                  if(that.onConnect){
                    that.onConnect(that.remote_id);
                  }
                }
              };
              const sessionDescription = await that.peer.createOffer();
              that.peer.setLocalDescription(sessionDescription);
            });
          }



          async answer(offerSDP){
            const that = this;
            return new Promise( async (resolve) => {
              that.peer = new RTCPeerConnection(that.pc_config);
              const offer = new RTCSessionDescription({
                type : 'offer',
                sdp : offerSDP,
              });
              await that.peer.setRemoteDescription(offer);

              //answer側ではcreateではなくイベントでdatachannelを取得する
              that.peer.ondatachannel = (event) => {
                const channel = event.channel;
                //createDataChannelで指定した名前はリモートでもlabelの値に反映される
                that.setup_channel(channel.label,channel);
              }

              that.peer.onicecandidate = (evt)=> {
                if (evt.candidate) {
                  console.log(evt.candidate);
                } else {
                  //この時点でsdpが確定する
                  console.log('empty ice event');
                  //コールバックだと見通しが悪いのでPromiseで値を返す
                  resolve(that.peer.localDescription);
                }
              };

              this.peer.onconnectionstatechange = (ev) => {
                console.log("onconnectionstatechange",that.peer.connectionState);
                if(that.peer.connectionState=="disconnected"){
                  if(that.onDisconnect){
                    that.onDisconnect(that.remote_id);
                  }
                }else if(that.peer.connectionState=="connected"){
                  if(that.onConnect){
                    that.onConnect(that.remote_id);
                  }
                }
              };
              const answer = await that.peer.createAnswer();
              that.peer.setLocalDescription(answer);
            });

          }

          async finishOffer(answerSDP){
            const answer = new RTCSessionDescription({
              type : 'answer',
              sdp : answerSDP,
            });
            await this.peer.setRemoteDescription(answer);
            console.log("finish offer");
          }
          close(){
            if(this.peer){
              this.peer.close();
            }
          }
          canSend(channel_name){
            if(channel_name in this.channels){
              return (this.channels[channel_name].readyState=="open");
            }else{
              return false;
            }
          }
          
          send(channel_name,data){
            if(channel_name in this.channels){
              if(this.channels[channel_name].readyState=="open"){
                this.channels[channel_name].send(data);
              }else{
                console.log("channel ",channel_name ,"in",this.remote_id ," not open ",this.channels[channel_name].readyState);
              }
            }
          }
        }
        
        
        //送信用データをエンコード
        const packTransform = (x,y,z,ry,forward,right,rotate,vx,vy,vz)=> {
          const buffer =new ArrayBuffer(4+4+4+4+4+4+4+4+4+4);
          const view =  new DataView(buffer);
          view.setFloat32(0,x);
          view.setFloat32(4,y);
          view.setFloat32(8,z);
          view.setFloat32(12,ry);
          view.setFloat32(16,forward);
          view.setFloat32(20,right);
          view.setFloat32(24,rotate);
          view.setFloat32(28,vx);
          view.setFloat32(32,vy);
          view.setFloat32(36,vz);
          return buffer;
        };
        
        //受信データをデコード
        const unpackTransform = (buffer) =>{
          var view = new DataView(buffer);
          return {
            x:view.getFloat32(0),
            y:view.getFloat32(4),
            z:view.getFloat32(8),
            ry:view.getFloat32(12),
            forward:view.getFloat32(16),
            right:view.getFloat32(20),
            rotate:view.getFloat32(24),
            vx:view.getFloat32(28),
            vy:view.getFloat32(32),
            vz:view.getFloat32(36),
          };
        }
        

        var avatars = {};//接続idとアバターの辞書。値は後で定義するAvatarクラス
        
        //位置同期は全員に
        const sendTransform = (x,y,z,ry,forward,right,rotate,vx,vy,vz) =>{
          const data = packTransform(x,y,z,ry,forward,right,rotate,vx,vy,vz);
          for(const id in connections){
            const conn = connections[id];
            conn.send("transform",data);
          }
        }
        //初期モーション定義
        const MOTIONS = [
          {name:"walk",path:"asset/animation/walk.fbx"},
          {name:"idle",path:"asset/animation/idle.fbx"},
        ];

        var local_avatar = null;
        const createLocalPlayer = async (id,name) =>{
          const avatar = new Avatar({
            id:id,
            name:name,
            motions:MOTIONS,
            scene:scene,
            ticks:dic_ticks,
            procVelocity:procVelocityLocal,
            procMotion:procMotion,
            procMove:procMove,
            onclick:toggleEmote,
          });
          

          local_avatar = avatar;
          avatars[id]=avatar;

          //初期アバター設定
          await avatar.setAvatar(default_avatar_url);
          //初期モーション設定
          avatar.playMotion("idle");
          
          //ローカルプレイヤーに物理判定追加
          createPlayerBody(avatar.container);


          //操作系の生成
          const input_system = new InputSystem({
            avatar:avatar,
            camera:camera,
            canvasElement:canvasElement,
            sendTransform:sendTransform,
            ticks:dic_ticks,
            key_events:{
              "KeyM":(e)=>{toggleEmote();},
              "Space":(e)=>{
                setPlayerJump(4);
              }            
            },
            fixFollowCamera:fixFollowCamera,
          });

          //ローカルプレイヤーが生成された時点で時間は回り始めることにする
          animation_loop();
        }

        
        const createOther = async (id,name) =>{
            const avatar = new Avatar({
              id:id,
              name:name,
              motions:MOTIONS,
              scene:scene,
              ticks:dic_ticks,
              procVelocity:procVelocityOther,
              procMotion:procMotion,
              onclick:()=>{},
            });
            avatars[id]=avatar;
            //初期アバター設定
            await avatar.setAvatar(default_avatar_url);
            //初期モーション設定
            avatar.playMotion("idle");
        }

        const removeOther = (id) =>{
          if(id in avatars){
            avatars[id].dispose();
            delete avatars[id];
          }
        }

        const moveOther = (id,data) =>{
          if(id in avatars){
            const pos = unpackTransform(data);
            avatars[id].setRemoteInput(pos.x,pos.y,pos.z,pos.ry,pos.forward,pos.right,pos.rotate,pos.vx,pos.vy,pos.vz);
          }
        }
        
        const sayOther = (id,message) =>{
          if(id in avatars){
            avatars[id].say(message);
          }
        }
        
        var local_avatar_data = null;
        var local_avatar_name = null;
        
        //他のプレイヤーにアバターを送信する
        const sendAvatar = async (id) =>{
          if(!local_avatar_data){
            //アバターデータなしなら通知しない
            return;
          }
          prepareSendFile(self_id,id,local_avatar_name,local_avatar_data,"avatar");
        }
        
        //ローカルアバター作成時
        const restoreLocalAvatar = async () =>{
          const info = await db.getData("vrm","my_avatar");
          if(info){
            if(self_id in avatars){
              await avatars[self_id].setAvatar(info.data);
            }
            local_avatar_data = info.data;
            local_avatar_name = info.filename;
          }
        };
        
        //ユーザー操作でアバター設定したとき
        const setLocalAvatar = async (data,filename) =>{
          if(self_id in avatars){
            await avatars[self_id].setAvatar(data);
          }
          local_avatar_data = data;
          local_avatar_name = filename;
          //indexedDBへの保存
          await db.setData("vrm","my_avatar",{"filename":filename,"data":data});
        }
        //リモートアバターを受信完了したとき
        const setRemoteAvatar = async (id,data,filename) =>{
          if(id in avatars){
            await avatars[id].setAvatar(data);
          }
        }


        //ユーザー操作でモーション設定したとき
        const setLocalMotion = async (data,filename) =>{
          if(self_id in avatars){
            await avatars[self_id].registMotion(data,filename,true);
            await avatars[self_id].playMotion(filename);
            setupEmote();
          }
          local_avatar_data = data;
          local_avatar_name = filename;
          //indexedDBへの保存
          await db.setData("fbx",filename,{"filename":filename,"data":data});
        }
        
        //リモートからモーションを受信完了したとき
        //相手が新規にモーション追加した場合か
        //未知のエモートに対する問い合わせに対する送信後なので即時再生
        const setRemoteMotion = async (id,data,filename) =>{
          if(id in avatars){
            await avatars[id].registMotion(data,filename,true);
            await avatars[id].playMotion(filename);
          }
        }
        



        
        //ログ表示
        const appendLog  = (msg) => {
          const li = document.createElement("li");
          li.textContent = msg;
          log_list.appendChild(li);
          li.scrollIntoView();
        };
        const appendLogElement  = (li) => {
          log_list.appendChild(li);
          li.scrollIntoView();
        };


        //シグナリングサーバとの接続
        const ws = new WebSocket(server_url);
        
        const doAuth = async (token) =>{
          const auth_msg = {"mode":"auth","token":token,"world":world,"room":room};
          ws.send(JSON.stringify(auth_msg));
        };
        
        const doLogin = async () =>{
          const info = await loginAsync();
          if(!info){
            return false;
          }else{
            const login_msg = {"mode":"login","user_id":info.user_id,"password":info.password,"world":world,"room":room};
            ws.send(JSON.stringify(login_msg));            
            return true;
          }
        };
        
        const onConnect = async () =>{
          const token = sessionStorage.getItem(token_name);
          if(token){
            //tokenによる認証を試みる
            await doAuth(token);
          }else{
            //ローカルDBを削除してアバターとモーション削除
            await db.removeDatabase();
            //idとパスワードによる認証を試みる
            let ret = false;
            while(!ret){
              ret = await doLogin();
            }
          }
        }
        
        const onNeedLogin = async () =>{
          //他の人のアバターが初期にになるのを防ぎたいので
          //ログインが必要になった時点でDB上のアバターとモーションは削除
          //データ保護の観点でいうとローカルDBに保存している時点で効果はない。
          //DB保存は、クライアントの状態がおかしくなったときのリロードや部屋移動の時に維持するのが目的
          await db.removeDatabase();
          let ret = false;
          while(!ret){
            ret = await doLogin();
          }
        }
        
        //シグナリングサーバからのログイン成功通知
        //このサンプルでは新規参加側がofferする
        const onWelcome = async (info)=>{
          
          //ログインするまではアバター情報へのアクセスは発生しない。
          await db.openDatabase();

        

          //トークン保存
          const token = info.token;
          sessionStorage.setItem(token_name,token);
          
          self_id = info.id;
          
          //入力処理登録
          await createLocalPlayer(info.id,info.name);
          
          //アバター復元
          await restoreLocalAvatar();
          //この時点では接続確立していないのでまだ送信できない
          
          //モーション復元
          await restoreEmote();
          

          //部屋移動したのでメンバーリスト再構成
          while(sel_members.length>0){
            sel_members.remove(0);
          };
          //membersから再構成
          id2name = {};
          {
            const opt = document.createElement("option");
            opt.value = "";
            opt.text = "全体発信";
            sel_members.add(opt);
          }
          for(const m of info.members){
            const opt = document.createElement("option");
            opt.value = m.id;
            opt.text = m.name;
            sel_members.add(opt);
            id2name[m.id]=m.name;
          }
          appendLog(room+"に参加しました");
          console.log(id2name);
          
          //既存メンバーにoffer投げる
          for(const target in id2name){
            startOffer(target);
          }
          
          //この時点で入力を受け付けるようにする。
          //実際に届くようになるのはp2p接続確立後
          inp_message.addEventListener('keydown', (e) => {
            //keyCodeは非推奨だが日本語変換と判別する都合これしかない
            if(!inp_message.value){
              //メッセージなし
              return;
            }
            if(e.keyCode === 13) {
              const target = sel_members.options[sel_members.selectedIndex].value;
              const message_body = inp_message.value;
              const target_name = id2name[target]; 
              
              //アバターからの発言表示
              local_avatar.say(message_body);
              
              if(target){
                const tell_msg = {"mode":"tell","target":target,"message":message_body};

                if(target in connections){
                  connections[target].send("chat",JSON.stringify(tell_msg))
                }
                appendLog("あなた>>"+target_name+": "+message_body);
              }else{
                const say_msg = {"mode":"say","target":target,"message":message_body};
                for(const id in connections){
                  connections[id].send("chat",JSON.stringify(say_msg))
                }
                appendLog("あなた: "+message_body);
              }
              inp_message.value="";
            }
          });
          btn_move_room.onclick= async (e) =>{
            await moveRoom();
          };
        }




        //シグナリングサーバからの参加通知処理
        //このサンプルでは、新規参加側がofferするのでここではofferしない
        const onJoin = (info) =>{
          //参加したメンバーを追加
          const opt = document.createElement("option");
          opt.value = info.id;
          opt.text = info.name;
          sel_members.add(opt);
          appendLog("["+info.name+"]が参加しました");
          id2name[info.id]= info.name;
          console.log(id2name);
          
        }
        
        //シグナリングサーバからの離脱通知処理
        const onLeave = (info) =>{
          //離脱したメンバーを削除
          var name = id2name[info.id];
          for(let i=0;i<sel_members.length;i++){
            const opt = sel_members.options[i];
            if(opt.value == info.id){
              sel_members.remove(i);
              delete id2name[info.id];
              if(info.id in connections){
                connections[info.id].close();
                delete connections[info.id];
              }
              //アバター削除
              removeOther(info.id);
              break;
            }
          }
          appendLog("["+name+"]が離脱しました");
          console.log(id2name);
        }
        
        //offer開始処理
        const startOffer = async (target) =>{
          const conn = new P2PConnection({
            local_id:self_id,
            remote_id:target,
            pc_config:pc_config,
            channels_def:channels_def,
            onConnect:onConnectP2P,
            onClose:onDisconnectP2P,
            onUnknownChannel:onUnknownChannel,
          });
          connections[target] = conn;
          const desc = await conn.offer();
          sendOffer(self_id,target,desc);
        };


        //シグナリングサーバからのoffer受信時処理
        const onOffer = async (info) =>{
          const conn = new P2PConnection({
            local_id:self_id,
            remote_id:info.sender,
            pc_config:pc_config,
            channels_def:channels_def,
            onConnect:onConnectP2P,
            onDisconnecte:onDisconnectP2P,
            onUnknownChannel:onUnknownChannel,
          });
          connections[info.sender] = conn;
          const desc = await conn.answer(info.description.sdp);
          sendAnswer(self_id,info.sender,desc);
        }

        //シグナリングサーバからのanswer受信時処理
        const onAnswer = async (info) =>{
          if(info.sender in connections){
            await connections[info.sender].finishOffer(info.description.sdp);
          }
        }

        //P2P接続時イベント
        const onConnectP2P = (from) =>{
          if(from in id2name){
            appendLog(id2name[from]+"とのP2P接続が確立しました。");
          }
        }

        //P2P切断時イベント
        const onDisconnectP2P = (from) =>{
          if(from in id2name){
            appendLog(id2name[from]+"とのP2P接続が切断されました。");
          }
        }
        
        //offerをシグナリングサーバに送信する関数
        const sendOffer = (from,to,description) =>{
          const offer_msg = {"mode":"offer","target":to,"description":description};
          ws.send(JSON.stringify(offer_msg));
        }

        //answerをシグナリングサーバに送信する関数
        const sendAnswer = (from,to,description) =>{
          const answer_msg = {"mode":"answer","target":to,"description":description};
          ws.send(JSON.stringify(answer_msg));
        }


        
        var connected = false;
        ws.onopen = (event) => {
          connected = true;
          appendLog("シグナリングサーバに接続しました");
          onConnect();
        };
        ws.onclose = (event) => {
          if(connected){
            appendLog("シグナリングサーバとの接続が切断されました");
          }
        };
        ws.onerror = async (event) => {
          if(ws.readyState==3){
            appendLog("シグナリングサーバに接続できません");
          }else{
            appendLog("通信エラーが発生");
          }
        };
        //シグナリングサーバからのメッセージ処理
        ws.onmessage = (event) =>{
          const message = event.data;
          console.log(message);
          const info = JSON.parse(message);
          if(info.mode=="need_login"){
            onNeedLogin();
          }else if(info.mode=="welcome"){
            onWelcome(info);
          }else if(info.mode=="join"){
            onJoin(info);
          }else if(info.mode=="leave"){
            onLeave(info);
          }else if(info.mode=="offer"){
            onOffer(info);
          }else if(info.mode=="answer"){
            onAnswer(info);
          }else if(info.mode=="attacked"){
            appendLog("何者かがあなたのアカウントでログインを試みています");
          }else if(info.mode=="sameuser"){
            appendLog("同じアカウントでログインしている人がいます");
          }
        };
      };
      init();
    </script>
  </body>
</html>